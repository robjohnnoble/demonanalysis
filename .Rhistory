strsplit("23_fg", "_")
strsplit(c("23_fg", "dfdf_43"), "_")
strsplit(c("23_fg", "dfdf_43"), "_")[1]
strsplit(c("23_fg", "dfdf_43"), "_")[[1]]
?strsplit
?list.dirs
strsplit(c("23_fg", "dfdf_43"), "_")[[]][1]
strsplit(c("23_fg", "dfdf_43"), "_")[[1:2]][1]
strsplit(c("23_fg", "dfdf_43"), "_")[[1:2]]
strsplit(c("23_fg", "dfdf_43"), "_")[1]
strsplit(c("23_fg", "dfdf_43"), "_")[1:2]
strsplit(c("23_fg", "dfdf_43"), "_")[[1:2]]
strsplit(c("23_fg", "dfdf_43"), "_")[[1]]
strsplit(c("23_fg", "dfdf_43"), "_")[[2]]
strsplit(c("23_fg", "dfdf_43"), "_")[]
strsplit(c("23_fg", "dfdf_43"), "_")[][1]
unlist(strsplit(c("23_fg", "dfdf_43"), "_"))
g <- strsplit(c("23_fg", "dfdf_43"), "_")
lapply(g, function (x) x[1])
lapply(g, function (x) x[length(x)])
unlist(lapply(g, function (x) x[length(x)]))
which.max(c(1,2,3,5,4))
library(devtools)
install.packages("devtools")
library(devtools)
devtools::install_github("greta-dev/greta@dev")
library(greta)
install_tensorflow()
install.packages('DiagrammeR')
(z <- ones(3, 3))
(z2 <- z + z ^ 2)
install_tensorflow(extra_packages = "tensorflow-probability")
install_tensorflow(extra_packages = "tensorflow-probability")
(z <- ones(3, 3))
(z2 <- z + z ^ 2)
(a <- variable(dim = c(3, 3)))
(a2 <- a + a ^ 2)
3844 / 3
log2(8)
log2(9)
floor(log2(9))
max(2^floor(log2(9)), 32)
min(2^floor(log2(9)), 32)
min(2^floor(log2(99)), 32)
min(2^floor(log2(19)), 32)
99 / (23-3)*0.8
99 / ((23-3)*0.8)
99 / ((23-6)*0.8)
102 / ((23-6)*0.8)
8.25*17
8.25*(17*0.8)
library(dplyr)
df1 <- data.frame(a=1:3,b=1:3)
slice(df1)
slice(df1,1)
2715/60
library(demonanalysis)
library(readr)
library(dplyr)
library(pracma)
library(scales)
data_dir <- "/Users/rnoble/Documents/MontpellierDocuments/Models/Demon/EulerData/July9thBigKNeutral"
plot_dir <- "/Users/rnoble/Documents/MontpellierDocuments/Models/Demon/EulerPlots/July9thBigKNeutral"
num_parameters <- 18
min_count <- 20
seed_index <- which(colnames(data) == "seed")
pars_without_seed <- (1:num_parameters)[which((1:num_parameters) != seed_index)]
data <- read_csv(paste0(data_dir, "/data.csv"), guess_max = 1E4)
data <- add_columns(data, num_parameters = num_parameters)
data <- add_relative_time(data, start_size = 50000, num_parameters = num_parameters)
data_dir_selection <- "/Users/rnoble/Documents/MontpellierDocuments/Models/Demon/EulerData/July5thBigKSeed100MuPass1"
data_s <- read_csv(paste0(data_dir_selection, "/data.csv"), guess_max = 1E4)
data_s <- add_columns(data, num_parameters = num_parameters)
data_s <- read_csv(paste0(data_dir_selection, "/data.csv"), guess_max = 1E4)
data_s <- add_columns(data_s, num_parameters = num_parameters)
data_s <- add_columns(data_s, num_parameters = num_parameters)
data %>% group_by(K, migration_type, migration_edge_only) %>%
filter(NumCells == max(NumCells)) %>%
summarise(MedianGen = median(Generation), MeanBirthRate = mean(MeanBirthRate))
data_s %>% group_by(K, migration_type, migration_edge_only) %>%
filter(NumCells == max(NumCells)) %>%
summarise(MedianGen = median(Generation), MeanBirthRate = mean(MeanBirthRate))
1.1^5
data_s %>% group_by(K, migration_type, migration_edge_only) %>%
filter(NumCells == max(NumCells)) %>%
summarise(MedianGen = median(Generation), MedianBirthRate = median(MeanBirthRate), MedianDrivers = median(Drivers))
3^(1/5)
ds <- data_s %>% group_by(K, migration_type, migration_edge_only) %>%
filter(NumCells == max(NumCells)) %>%
summarise(MedianGen = median(Generation), MedianBirthRate = median(MeanBirthRate), MedianDrivers = median(Drivers))
dn <- data %>% group_by(K, migration_type, migration_edge_only) %>%
filter(NumCells == max(NumCells)) %>%
summarise(MedianGen = median(Generation), MedianBirthRate = median(MeanBirthRate), MedianDrivers = median(Drivers))
merge(ds, dn)
cbind(ds, dn)
?cbind
?merge
merge(ds, dn, all = T)
merge(ds, dn, all.x = T)
merge(ds, dn, by = c("K", "migration_type", "migration_edge_only"))
dns <- merge(ds, dn, by = c("K", "migration_type", "migration_edge_only"))
View(dns)
View(dns)
mean(dns$MedianGen.y)
(1-1/0.1)/(1-1/0.1^32)
(1-1/1.1)/(1-1/1.1^32)
(1-1/1.1)/(1-1/1.1^(2^13))
(1-1/1.1)/(1-1/1.1^(2^0))
(1-1/1.1)/(1-1/1.1^(2^1))
(1-1/1.1)/(1-1/1.1^(2^5))
(1-1/1.1)
colnames(data)
data %>% group_by(K, migration_type, migration_edge_only) %>%
filter(NumCells == max(NumCells)) %>%
summarise(MedianGen = median(Generation), MeanBirthRate = mean(MeanBirthRate), MigRate = mean(init_migration_rate))
library(demonanalysis)
library(readr)
library(dplyr)
library(pracma)
library(scales)
data_dir <- "/Users/rnoble/Documents/MontpellierDocuments/Models/Demon/EulerData/July9thBigKNeutral"
plot_dir <- "/Users/rnoble/Documents/MontpellierDocuments/Models/Demon/EulerPlots/July9thBigKNeutral"
num_parameters <- 18
min_count <- 20
seed_index <- which(colnames(data) == "seed")
pars_without_seed <- (1:num_parameters)[which((1:num_parameters) != seed_index)]
data <- read_csv(paste0(data_dir, "/data.csv"), guess_max = 1E4)
data <- add_columns(data, num_parameters = num_parameters)
data <- add_relative_time(data, start_size = 50000, num_parameters = num_parameters)
data %>% group_by_at(1:num_parameters) %>%
mutate(SmoothRadius = 10^loess(log10(sqrt(NumCells/pi)) ~ log10(Generation + 1), span = 0.75)$fitted) %>%
ungroup()
dim(data)
data <- data %>% group_by_at(1:num_parameters) %>%
mutate(SmoothRadius = 10^loess(log10(sqrt(NumCells/pi)) ~ log10(Generation + 1), span = 0.75)$fitted) %>%
ungroup()
data <- data %>% group_by_at(1:num_parameters) %>%
mutate(RadiusGrowthRate = (SmoothRadius - lag(SmoothRadius, 1)) / (Generation - lag(Generation, 1))) %>%
ungroup()
plot_curves_faceted(data, num_parameters, x_var = "SmoothRadius", y_var = "GrowthRate",
log = "xy", xlimits = c(1, 1E6), ylimits = c(1, 1E5),
output_filename = "radius_numcells_log",
output_dir = plot_dir, line_col = "rank_GrowthRate0", alpha = 0.5)
colnames(data)
data <- add_columns(data, num_parameters = num_parameters)
colnames(data)
df <- data.frame(p = 1, seed = rep(1:2, each = 10),
Generation = c(1:10, 3:12), NumCells = rep(1:10, times = 2) + rnorm(20, 0, 0.1))
add_columns(df, 2)
add_columns
library(devtools)
setwd("/Users/rnoble/Documents/GitHub/demonanalysis")
check()
check()
check()
library(devtools)
getwd()
check()
library(demonanalysis)
library(readr)
library(dplyr)
library(pracma)
library(scales)
data_dir <- "/Users/rnoble/Documents/MontpellierDocuments/Models/Demon/EulerData/July9thBigKNeutral"
plot_dir <- "/Users/rnoble/Documents/MontpellierDocuments/Models/Demon/EulerPlots/July9thBigKNeutral"
num_parameters <- 18
min_count <- 20
seed_index <- which(colnames(data) == "seed")
pars_without_seed <- (1:num_parameters)[which((1:num_parameters) != seed_index)]
data <- read_csv(paste0(data_dir, "/data.csv"), guess_max = 1E4)
data <- add_columns(data, num_parameters = num_parameters)
data <- add_relative_time(data, start_size = 50000, num_parameters = num_parameters)
colnames(data)
data <- data %>% group_by_at(1:num_parameters) %>%
mutate(SmoothRadius = 10^loess(log10(sqrt(NumCells/pi)) ~ log10(Generation + 1), span = 0.75)$fitted) %>%
ungroup()
data <- data %>% group_by_at(1:num_parameters) %>%
mutate(RadiusGrowthRate = (SmoothRadius - lag(SmoothRadius, 1)) / (Generation - lag(Generation, 1))) %>%
ungroup()
plot_curves_faceted(data, num_parameters, x_var = "SmoothRadius", y_var = "GrowthRate",
log = "xy", xlimits = c(1, 1E6), ylimits = c(1, 1E5),
output_filename = "radius_numcells_log",
output_dir = plot_dir, line_col = "rank_GrowthRate0", alpha = 0.5)
plot_curves_faceted(data, num_parameters, x_var = "SmoothRadius", y_var = "Generation",
log = "xy", xlimits = c(1, 1E6), ylimits = c(1, 1E5),
output_filename = "radius_numcells_log",
output_dir = plot_dir, line_col = "rank_GrowthRate0", alpha = 0.5)
plot_curves_faceted(data, num_parameters, x_var = "SmoothRadius", y_var = "Generation",
xlimits = c(1, 1E6), ylimits = c(1, 1E5),
output_filename = "radius_numcells",
output_dir = plot_dir, line_col = "rank_GrowthRate0", alpha = 0.5)
plot_curves_faceted(data, num_parameters, x_var = "Generation", y_var = "SmoothRadius",
log = "xy", xlimits = c(1, 1E6), ylimits = c(1, 1E5),
output_filename = "radius_numcells_log",
output_dir = plot_dir, line_col = "rank_GrowthRate0", alpha = 0.5)
plot_curves_faceted(data, num_parameters, x_var = "Generation", y_var = "SmoothRadius",
xlimits = c(1, 1E4), ylimits = c(1, 1E3),
output_filename = "radius_numcells",
output_dir = plot_dir, line_col = "rank_GrowthRate0", alpha = 0.5)
plot_curves_faceted(data, num_parameters, x_var = "Generation", y_var = "SmoothRadius",
xlimits = c(1, 4000), ylimits = c(1, 700),
output_filename = "radius_numcells",
output_dir = plot_dir, line_col = "rank_GrowthRate0", alpha = 0.5)
plot_curves_faceted(data, num_parameters, x_var = "Generation", y_var = "RadiusGrowthRate",
log = "xy", xlimits = c(1, 4000), ylimits = c(1, 700),
output_filename = "radius_growth_rate_numcells",
output_dir = plot_dir, line_col = "rank_GrowthRate0", alpha = 0.5)
plot_curves_faceted(data, num_parameters, x_var = "Generation", y_var = "RadiusGrowthRate",
log = "xy", xlimits = c(1, 4000), ylimits = c(1e-3, 10),
output_filename = "radius_growth_rate_numcells",
output_dir = plot_dir, line_col = "rank_GrowthRate0", alpha = 0.5)
plot_curves_faceted(data, num_parameters, x_var = "NumCells", y_var = "RadiusGrowthRate",
log = "xy", xlimits = c(1, 4000), ylimits = c(1e-3, 10),
output_filename = "radius_growth_rate_numcells",
output_dir = plot_dir, line_col = "rank_GrowthRate0", alpha = 0.5)
plot_curves_faceted(data, num_parameters, x_var = "NumCells", y_var = "RadiusGrowthRate",
log = "xy", xlimits = c(1, 1e6), ylimits = c(1e-3, 10),
output_filename = "radius_growth_rate_numcells",
output_dir = plot_dir, line_col = "rank_GrowthRate0", alpha = 0.5)
plot_curves_faceted(data, num_parameters, x_var = "NumCells", y_var = "RadiusGrowthRate",
xlimits = c(1, 1e6), ylimits = c(0, 10),
output_filename = "radius_growth_rate_numcells",
output_dir = plot_dir, line_col = "rank_GrowthRate0", alpha = 0.5)
plot_curves_faceted(data, num_parameters, x_var = "NumCells", y_var = "RadiusGrowthRate",
xlimits = c(1, 1e6), ylimits = c(0, 6),
output_filename = "radius_growth_rate_numcells",
output_dir = plot_dir, line_col = "rank_GrowthRate0", alpha = 0.5)
data %>% group_by(K, migration_type, migration_edge_only) %>%
filter(NumCells == max(NumCells)) %>%
summarise(MedianGen = median(Generation),
MedianBirthRate = median(MeanBirthRate),
MigRate = mean(init_migration_rate),
MedianRadiusGrowthRate = median(RadiusGrowthRate))
#'
#' @return A number, corresponding to expected migration rate per deme.
#'
#' @details Assumes that min(d / sqrt(K), 1) is the probability that a migration attempt will land outside the deme.
#' Importantly, does not account for the chance that the migrating cell will land in an already-occupied deme.
#'
#' @export
#'
#' @examples
#' lambda
lambda <- function(i, K, d, m, r1, r2, selection = "birth") {
res <- m * i * min(d / sqrt(K), 1)
if(selection == "birth & migration") return(r1 * r2 * res)
else return(res)
}
lambda(1, 2, 1, 0.1, 1, 1.1)
lambda(1, 2, 1, 0.1, 1, 1.1)^2
#' @param i number of cells of the focus type
#' @param K deme carrying capacity
#' @param r relative fitness of the focus type
#'
#' @return A number, corresponding to probability of fixation.
#'
#' @export
#'
#' @examples
#' lambda(1, 2, 1, 0.1, 1, 1.1)
rho <- function(i, K, r) {
if(r == 1) return(i/K)
if(r == 0) return(0)
else return((1-1/r^i) / (1-1/r^K))
}
rho(1, 2, 1.1)
rho(1, 8, 1.1)
rho(1, 8, 0.9)
#' @param r1 birth rate of cells in the destination deme, relative to reference birth rate
#' @param r2 birth rate of migrating cells, relative to r1
#' @param selection one of "birth", "death", "birth & migration"
#'
#' @return A number, corresponding to the rate.
#'
#' @export
#'
#' @examples
#' lambda_invasion(1, 2, 1, 0.1, 1, 1.1)
lambda_invasion <- function(i, K, d, m, r1, r2, selection = "birth") {
res <- lambda(i, K, d, m, r1, r2, selection) * rho(1, K, r2)
# note that the destination deme temporarily has population size K+1
if(selection == "death") return(res * K / (K + 1 / r2))
else if(selection == "birth & migration" || selection == "birth")  return(res * K / (K + 1))
else stop("Invalid selection option")
}
lambda_invasion(1, 2, 1, 0.1, 1, 1.1)
lambda_invasion(1, 2, 1, 0.1, 1, 1.1, "death")
lambda_invasion(1, 2, 1, 0.1, 1, 1.1, "birth")
#' @param j
#' @param r
#' @param K
#'
#' @return A number, corresponding to the rate.
#'
#' @export
#'
#' @examples
#' lambda_invasion(1, 2, 1, 0.1, 1, 1.1, "birth")
trans_rate <- function(i, j, r, K) {
base <- (K-i)/(r*i+K-i)*i/K
res <- NA
if(j == 0) res <- 1
if(i == K) res <- 1
if(j == i-1) res <- base
if(i == j) res <- 1 - base - r*base
if(j == i+1) res <- r*base
return(res)
}
trans_rate(1, 2, 1.1, 16)
trans_rate(1, 2, 1.1, 4)
trans_rate(1, 0, 1.1, 4)
trans_rate(1, 0, 11, 4)
trans_rate(1, 2, 11, 4)
trans_rate(1, 2, 1111, 4)
trans_rate(3, 0, 1.1, 4)
#' @param r1 birth rate of cells in the destination deme, relative to reference birth rate
#' @param r2 birth rate of migrating cells, relative to r1
#' @param selection one of "birth", "death", "birth & migration"
#'
#' @return A number, corresponding to the time.
#'
#' @export
#'
#' @examples
#' time_migration(2, 1, 0.1, 1, 1.1, "birth")
time_migration <- function(K, d, m, r1, r2, selection = "birth") {
1 / lambda_invasion(K, K, d, m, r1, r2, selection)
}
time_migration(2, 1, 0.1, 1, 1.1, "birth")
time_migration(2, 1, 0.1, 1, 1.1, "death")
#'
#' @return A number, corresponding to the time.
#'
#' @export
#'
#' @details See Traulsen 2009, equation 1.38.
#'
#' @examples
#' time_fixation(1, 1.1, 4)
#' time_migration(2, 1, 0.1, 1, 1.1, "death")
time_fixation <- function(r1, r2, K, r_powers_shifted = NA) {
if(K == 1) return(0)
if(r2 == 1) return(K - 1)
if(is.na(r_powers_shifted[1])) r_powers_shifted <- r2^(0:K)
l <- 1:(K-1)
sum <- sum((1 - 1 / r_powers_shifted[l + 1]) * (r2 * l + K - l) * (1 - 1 / r_powers_shifted[K - l + 1]) / (l * (K - l)))
if(r2^K > 1e20) {
sum <- sum * 1 / (r2 - 1)
} else {
sum <- sum * r2^K / ((r2^K - 1) * (r2 - 1))
}
return(sum/r1) # relative to the doubling time of a cell with birth rate 1
}
time_fixation(1, 1.1, 4)
#' @param K deme carrying capacity
#'
#' @return A number, corresponding to the time.
#'
#' @export
#'
#' @details See Traulsen 2009, equations 1.38 and 1.39.
#'
#' @examples
#' T_grow_j(3, 1, 1.1, 4)
T_grow_j <- function(j, r1, r2, K) {
if(j > K) return(Inf)
if(j <= 1 || K <= 1) return(0)
if(j == K) return(time_fixation(r1, r2, K))
r_powers_shifted <- r2^(0:K) # need to add one to the index!
t1 <- time_fixation(r1, r2, K, r_powers_shifted)
if(r2 == 1) sum1 <- K / j - 1
else {
sum1 <- (r2^(1-j) - r2^(1-K)) / (r2 - 1) # sum of 1/r2^k from k=j to k=K-1
sum1 <- sum1 * (1 - 1/r2) / (1 - 1/r2^j) # ratio rho(1)/rho(j)
}
l <- 1:(K-1)
if(r2 == 1) sum2 <- K / j * sum((K - pmax(j, l)) / (K - l))
else {
sum2 <- sum((1 - 1 / r_powers_shifted[l + 1]) * (r2 * l + K - l) * (1 / r_powers_shifted[pmax(j, l) - l + 1] - 1 / r_powers_shifted[K - l + 1]) / (l * (K - l)))
if(r2^j > 1e20) {
sum2 <- sum2 / (r2 - 1)
} else {
sum2 <- sum2 * r2^j / ((r2^j - 1) * (r2 - 1))
}
}
return((t1 * (1 + sum1) - sum2 / r1)) # relative to the doubling time of a cell with birth rate 1
}
T_grow_j(3, 1, 1.1, 4)
T_grow_j(4, 1, 1.1, 4)
#' @param d migration distance relative to 1/sqrt(K)
#' @param m migration rate per cell, relative to birth rate
#' @param selection one of "birth", "death", "birth & migration"
#'
#' @return A number, corresponding to the time.
#'
#' @export
#'
#' @examples
#' time_migration(2, 1, 0.1, 1, 1.1, "birth")
time_expected <- function(r1, r2, K, d, m, selection = "birth"){
if(K == 1) return(time_migration(K, d, m, r1, r2, selection))
lambda_list <- sapply(1:K, lambda_invasion, K=K, d=d, m=m, r1=r1, r2=r2, selection = selection)
t_list <- sapply(1:K, T_grow_j, r1=r1, r2=r2, K=K)
# first summand
l <- 1:K
part1 <- (lambda_list[l] * t_list[l] + 1) * exp(-lambda_list[l] * t_list[l])
part2 <- (lambda_list[l] * t_list[l + 1] + 1) * exp(-lambda_list[l] * t_list[l + 1])
exponent_sum <- sapply(1:(K-1), function(i) sum(lambda_list[1:(i-1)] * (t_list[1:(i-1)+1] - t_list[1:(i-1)])))
exponent_sum[1] <- 0
l <- 1:(K-1)
term1 <- sum(1/lambda_list[l] * exp(-exponent_sum[l] + lambda_list[l] * t_list[l]) * (part1[l] - part2[l]))
# second summand
l <- 1:(K-1)
exponent_sum <- sum(lambda_list[l] * (t_list[l+1] - t_list[l]))
term2 <- 1/lambda_list[K] * exp(-exponent_sum) * (lambda_list[K] * t_list[K] + 1)
return(term1 + term2)
}
time_expected(1, 1.1, 2, 1, 0.1, "birth")
time_expected(1, 1.1, 2, 1, 0.1, "death")
#'
#' @return A number, corresponding to the time.
#'
#' @export
#'
#' @details Assumes that the time until fixation is negligible relative to the time until migration.
#'
#' @examples
#' disp_rate_max(2, 1, 0.1, 1, 1.1, "birth")
#' disp_rate_max(2, 1, 0.1, 1, 1.1, "death")
disp_rate_max <- function(K, d, m, r1, r2, selection = "birth", symmetric = FALSE) {
if(!symmetric) return(sqrt(K) / time_migration(K, d, m, r1, r2, selection))
else return((sqrt(K) / time_migration(K, d, m, r1, r2, selection) - sqrt(K) / time_migration(K, d, m, r1, 1 / r2, selection))/2)
}
disp_rate_max(2, 1, 0.1, 1, 1.1, "birth")
disp_rate_max(2, 1, 0.1, 1, 1.1, "death")
#'
#' @return A number, corresponding to the speed.
#'
#' @export
#'
#' @details Assumes that a cell type cannot attempt to migrate until it reaches fixation.
#'
#' @examples
#' disp_rate_max(1, 1.1, 2, 1, 0.1, "birth")
#' disp_rate_max(1, 1.1, 2, 1, 0.1, "death")
disp_rate_min <- function(r1, r2, K, d, m, selection = "birth", symmetric = FALSE) {
if(!symmetric) return(sqrt(K) / (time_fixation(r1, r2, K) + time_migration(K, d, m, r1, r2, selection)))
else return((sqrt(K) / (time_fixation(r1, r2, K) + time_migration(K, d, m, r1, r2, selection)) - sqrt(K) / (time_fixation(r1, 1 / r2, K) + time_migration(K, d, m, r1, 1 / r2, selection)))/2)
}
disp_rate_min(1, 1.1, 2, 1, 0.1, "birth")
disp_rate_min(1, 1.1, 2, 1, 0.1, "death")
#'
#' @return A number, corresponding to the speed.
#'
#' @export
#'
#' @details Assumes that a cell type cannot attempt to migrate until it reaches fixation.
#'
#' @examples
#' disp_rate_min(1, 1.1, 2, 1, 0.1, "birth")
#' disp_rate_min(1, 1.1, 2, 1, 0.1, "death")
disp_rate <- function(r1, r2, K, d, m, selection = "birth", symmetric = FALSE) {
if(!symmetric) return(sqrt(K) / time_expected(r1, r2, K, d, m, selection))
else return((sqrt(K) / time_expected(r1, r2, K, d, m, selection) - sqrt(K) / time_expected(r1, 1 / r2, K, d, m, selection))/2)
}
disp_rate(1, 1.1, 2, 1, 0.1, "birth")
disp_rate(1, 1.1, 2, 1, 0.1, "death")
#' @return A number, corresponding to the speed.
#'
#' @export
#'
#' @details Assumes migration_type = 0, migration_edge_only = 0, migration_rate_scales_with_K = 1.
#' Adjustment for two-dimensional growth entails multiplying the migration rate by 0.4, which is
#' a factor estimated from simulation results.
#'
#' @examples
#' mig_rate(8)
mig_rate <- function(K, edge_only = 0, two_dim = FALSE) {
if(edge_only == 0) {
A <- -0.1593
B <- -0.2868
C <- 0.4646
} else {
A <- -0.2041
B <- -0.14
C <- 0.5761
}
if(two_dim) {
mult = 0.4 # approximately the right adjustment factor, based on simulation results
} else {
mult = 1
}
return(mult * 10^(A * (log10(K))^2 + B * log10(K) + C) / sqrt(K))
}
mig_rate(8)
#' @param two_dim whether to adjust for two-dimensional growth
#' @param r2 birth rate of migrating cells
#' @return A number, corresponding to the speed.
#'
#' @export
#'
#' @details Assumes migration_type = 0, migration_edge_only = 0, migration_rate_scales_with_K = 1.
#'
#' @examples
#' disp_rate_demon(8, 1/0.9)
disp_rate_demon <- function(K, r2, edge_only = 0, two_dim = FALSE) {
disp_rate(1, r2, K, sqrt(K), mig_rate(K, edge_only, two_dim), "birth")
}
disp_rate_demon(8, 1/0.9)
check()
check()
