% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/datacollation.R
\name{get_cor_summary}
\alias{get_cor_summary}
\title{Generate summary dataframe of correlations with "outcome"}
\usage{
get_cor_summary(summary, col_names_list, num_parameters, min_count,
  Verbose = FALSE, ReturnCI = FALSE, VariablesToNotGroupBy = NULL,
  method = "spearman")
}
\arguments{
\item{summary}{dataframe including columns named "seed", "Generation", "start_size", "start_time" and "outcome"}

\item{col_names_list}{char vector of column names in the summary dataframe}

\item{num_parameters}{number of parameters, accounting for the first set of columns in the dataframe}

\item{min_count}{minimum number of items in each column (otherwise result will be NA)}

\item{Verbose}{if TRUE, helpful to debug, print the name of the variables with which compute the correlation}

\item{ReturnCI}{if true, also return the 0.95 level confidence interval computed by bootstraping.}

\item{VariablesToNotGroupBy}{vector of column names by which we don't want to group the simulation. For example, if mutation rate (mu_driver_birth)
are random, then we don't want to group the simulations by the variable mu_driver_birth, so we need to set VariablesToNotGroupBy=c("mu_driver_birth")
This is more general than creating a boolean argument as CombinedMutationRate=TRUE/FALSE.}
}
\value{
Dataframe with one row for each unique combination of parameter values, gap and start_size 
(i.e. it summarises over "seed"), and including columns containing the correlations between "outcome" 
and each variable in col_names_list and the associated pValues for the two.sided test of the correlation coefficient.
If the argument ReturnCI=TRUE, the 0.95 Confidence Intervals for the correlation coefficients are also computed.
Argument VariablesToNotGroupBy allows to compute the correlation coefficients while not grouping simulations
by variables contained into VariablesToNotGroupBy.
}
\description{
Generate summary dataframe of correlations with "outcome"
}
\examples{
get_cor_summary(sum_df, c("DriverDiversity", "DriverEdgeDiversity"), 15, min_count = 2)
}
