#' Reflect a matrix on its leading diagonal (useful if distance matrix has entries in upper half only)
#' 
#' @param matrix square matrix
#' 
#' @return square matrix of same dimensions as input
#' 
#' @export
#' 
#' @examples
#' reflect_on_diagonal(matrix(1:9, ncol = 3))
reflect_on_diagonal <- function(matrix) {
  if(dim(matrix)[1] != dim(matrix)[2]) stop("Not a square matrix")
  matrix[lower.tri(matrix)] <- t(matrix)[lower.tri(t(matrix))]
  diag(matrix) <- 0
  return(matrix)
}

#' Get a "phylo" object from a relatedness matrix
#' 
#' @param matrix square matrix
#' 
#' @return An object of class phylo.
#' 
#' @export
#' @importFrom ape plot.phylo
#' @importFrom ape njs
#' @importFrom stats as.dist
#' 
#' @examples
#' tree <- get_tree_from_matrix(driver_matrix)
#' library(ape)
#' plot.phylo(tree, show.tip.label = FALSE)
get_tree_from_matrix <- function(matrix) {
  if(dim(matrix)[1] != dim(matrix)[2]) stop("Not a square matrix")
  matrix <- matrix[, colSums(is.na(matrix)) < nrow(matrix)] # remove any NA columns
  matrix <- reflect_on_diagonal(matrix) # copy upper half to lower half, reflected on the leading diagonal
  return(njs(as.dist(matrix))) # create tree object
}

#' Get the ancestry of each genotype
#' 
#' @param edges Dataframe comprising an adjacency matrix, with column names "Parent" and "Identity"
#' 
#' @return Dataframe listing the ancestors of each genotype (one row per Identity value).
#' 
#' @export
#' @importFrom ggmuller find_start_node
#' @importFrom ggmuller move_up
#' 
#' @examples
#' library(dplyr)
#' phylo <- filter(driver_phylo, CellsPerSample == -1)
#' library(ggmuller)
#' edges <- get_edges(phylo)
#' ancestry(edges)
ancestry <- function(edges) {
  start <- find_start_node(edges)
  anc <- data.frame(V1 = start)
  gens_list <- unique(edges$Identity)
  for(gen in 1:length(gens_list)) {
    now <- as.numeric(edges[gen, "Identity"])
    res <- now
    repeat {
      if(move_up(edges, now) == now) break
      now <- move_up(edges, now)
      res <- c(now, res)
    }
    res <- as.data.frame(t(res))
    anc <- bind_rows(anc, res)
  }
  max_len <- dim(anc)[2]
  colnames(anc) <- paste0("Level", 1:max_len)
  gens_list <- c(start, gens_list)
  anc <- cbind(anc, Identity = gens_list)
  rownames(anc) <- NULL
  return(anc)
}

#' Find the latest-occurring mutation shared by at least a threshold proportion of cells
#' 
#' @param anc Dataframe of ancestries, as generated by "ancestry" function
#' @param pop_subdf Dataframe with column names "Identity" and "Population"
#' @param threshold Number between 0 and 1; a genotype must exceed this frequency to be considered dominant
#' 
#' @return Identity of the dominant genotype.
#' 
#' @export
#' @import dplyr
#' 
#' @examples
#' library(ggmuller)
#' library(dplyr)
#' phylo <- filter(driver_phylo, CellsPerSample == -1)
#' pop_df <- get_population_df(phylo)
#' edges <- get_edges(phylo)
#' anc <- ancestry(edges)
#' pop_subdf <- filter(pop_df, Generation == max(Generation)) %>% select(Identity, Population)
#' dominant(anc, pop_subdf, 0.1)
dominant <- function(anc, pop_subdf, threshold) {
  anc <- merge(anc, pop_subdf)
  total_pop <- sum(anc$Population)
  max_len <- dim(anc)[2]
  for(level in 1:max_len) {
    col <- paste0("Level", level)
    dom <- anc %>% group_by_(col) %>% 
      filter(sum(Population) / total_pop >= threshold) %>% 
      select_(col)
    dom <- dom[!is.na(dom), ]
    if(dim(dom)[1] == 0) break
    else res <- max(dom)
  }
  return(res)
}

#' Find generations at which sweeps (or at least partial sweeps) occurred
#' 
#' @param phylo Dataframe containing phylogeny
#' @param threshold Number between 0 and 1; a genotype must exceed this frequency to be considered dominant
#' @param min_pop Genotypes with populations smaller than this size will be removed before analysis (default 0)
#' 
#' @return Vector of generations at which (partial) sweeps occurred.
#' 
#' @export
#' @import dplyr
#' @importFrom ggmuller get_population_df
#' @importFrom ggmuller get_edges
#' 
#' @examples
#' library(dplyr)
#' phylo <- filter(driver_phylo, CellsPerSample == -1)
#' sweep_times(phylo, threshold = 0.1)
sweep_times <- function(phylo, threshold, min_pop = 0) {
  pop_df <- get_population_df(phylo)
  pop_df <- filter(pop_df, Population >= min_pop)
  edges <- get_edges(phylo)
  anc <- ancestry(edges)
  res <- vector()
  for(generation in unique(pop_df$Generation)) {
    pop_subdf <- filter(pop_df, Generation == generation) %>% select(Identity, Population)
    dom <- dominant(anc, pop_subdf, threshold)
    if(generation > min(pop_df$Generation)) if(dom != prev_dom) res <- c(res, generation)
    prev_dom <- dom
  }
  return(res)
}

#' Calculate how the genotype frequency distribution changes over time
#' 
#' @param pop_df Dataframe with column names "Identity", "Population" and "Generation"
#' @param lag_type Either "generations" or "proportions" (default "generations")
#' @param breaks Number of breaks (used only if lag_type = "proportions"; default 10)
#' @param lag_gens Number of generations between  (used only if lag_type = "generations"; default 500)
#' 
#' @return For each generation g in pop_df, the output vector quantifies the change in genotype frequencies 
#' compared to generation g - lag_gens (by summing the squares of the differences).
#' 
#' @export
#' @import dplyr
#' @importFrom stats median
#' @importFrom graphics plot
#' 
#' @examples
#' library(ggmuller)
#' library(dplyr)
#' phylo <- filter(driver_phylo, CellsPerSample == -1)
#' pop_df <- get_population_df(phylo)
#' sweep_seq1 <- sweep_sequence(pop_df, lag_type = "proportions", breaks = 6)
#' sweep_seq2 <- sweep_sequence(pop_df, lag_type = "generations", lag_gens = 2)
#' identical(sweep_seq1, sweep_seq2)
#' sweep_df <- data.frame(y = sweep_seq2, x = (1:length(sweep_seq2))/length(sweep_seq2))
#' plot(y ~ x , data = sweep_df, type = "l")
sweep_sequence <- function(pop_df, lag_type = "generations", breaks = 10, lag_gens = 500) { #*
  if(lag_type != "generations" & lag_type != "proportions") stop("Lag type must be 'generations' or 'proportions'")
  # remove generations with total population zero:
  pop_df <- pop_df %>% group_by(Generation) %>% 
    filter(sum(Population) > 0) %>% 
    ungroup()
  # add frequency column:
  pop_df <- pop_df %>% group_by(Generation) %>% 
    mutate(Frequency = Population / sum(Population)) %>% 
    ungroup()
  # calculate lag in terms of generations:
  if(lag_type == "proportions") lag <- round(length(unique(pop_df$Generation))/breaks)
  else lag <- round(lag_gens / median(diff(unique(pop_df$Generation))))
  lag <- max(lag, 1)
  # calculate differences between frequencies separated by lag generations:
  pop_df <- group_by(pop_df, Identity) %>% 
    mutate(diff = (Frequency - lag(Frequency, n = lag))^2)
  # find sum of differences for each generation:
  #pop_df <- filter(pop_df, Generation >= min(pop_df$Generation) + (max(pop_df$Generation) - min(pop_df$Generation))/breaks)
  sum_df <- group_by(pop_df, Generation) %>% 
    summarise(sum_diff = sum(diff, na.rm=TRUE))
  return(sum_df$sum_diff)
}

#' Get genotype frequencies in increasing order of size
#' 
#' @param pop_df Dataframe with column names "Identity", "Population" and "Generation"
#' @param generation Generation at which to get frequencies (default NA corresponds to final generation)
#' 
#' @return vector of genotype frequencies
#' 
#' @export
#' @import dplyr
#' 
#' @examples
#' library(dplyr)
#' library(ggmuller)
#' phylo <- filter(driver_phylo, CellsPerSample == -1)
#' pop_df <- get_population_df(phylo)
#' dist <- geno_dist(pop_df)
#' barplot(dist, ylim = c(0, 1))
geno_dist <- function(pop_df, generation = NA) {
  if(is.na(generation)) generation = max(pop_df$Generation)
  # add frequency column:
  pop_df <- pop_df %>% group_by(Generation) %>% 
    mutate(Frequency = Population / sum(Population)) %>% 
    ungroup()
  pop_subdf <- filter(pop_df, Generation == generation)
  pop_subdf <- filter(pop_subdf, Frequency > 0)
  dist <- sort(pop_subdf$Frequency)
  return(dist)
}

#' Add derived variables to a dataframe
#' 
#' @param df dataframe with columns including "Generation"
#' 
#' @return the same dataframe with additional columns
#' 
#' @export
#' 
#' @examples
#' add_columns(output)
add_columns <- function(df) {
  df$maxgen <- max(df$Generation)
  df$gen_adj <- df$Generation / df$maxgen
  
  return(df)
}

#' Add columns to an output dataframe, containing parameter values and diversity metrics
#' 
#' @param full_dir base input directory name
#' @param res dataframe to which the result will be appended (default is an empty dataframe)
#' 
#' @return the same dataframe with additional columns
#' 
#' @importFrom readr read_delim
#' @importFrom dplyr bind_cols
#' 
#' @export
#' 
#' @examples
#' combine_dfs(system.file("extdata", "", package = "demonanalysis", mustWork = TRUE))
combine_dfs <- function(full_dir, res = data.frame()) {
  if(substr(full_dir, nchar(full_dir), nchar(full_dir)) == "/") full_dir <- substr(full_dir, 1, nchar(full_dir) - 1)
  file_pars <- paste0(full_dir, "/parameters.dat")
  file_out <- paste0(full_dir, "/output.dat")
  file_div <- paste0(full_dir, "/output_diversities.dat")
  
  df_pars <- read_delim(file_pars, "\t")
  df_out <- read_delim(file_out, "\t")
  df_div <- read_delim(file_div, "\t")
  
  df_out <- add_columns(df_out)
  
  temp <- merge(df_out, df_div, all = TRUE)
  temp <- cbind(df_pars, temp)
  
  return(rbind(res, temp))
}

#' Create a composite dataframe by combining data for every simulation in a batch
#' 
#' @param input_dir base input directory name
#' @param pars vector of parameter names
#' @param final_values vector of largest parameter values, of same length as pars
#' 
#' @return a combined dataframe
#' 
#' @export
all_output <- function(input_dir, pars, final_values) {
  N <- length(pars)
  if(N != length(final_values)) stop("Unequal lengths of pars and final_values.")
  
  res <- data.frame()
  
  if(N == 1) for(a in 0:final_values[1]) {
    full_dir <- make_dir(input_dir, pars, a)
    res <- combine_dfs(full_dir, res)
  }
  
  if(N == 2) for(a in 0:final_values[1]) for(b in 0:final_values[2]) {
    full_dir <- make_dir(input_dir, pars, c(a, b))
    res <- combine_dfs(full_dir, res)
  }
  
  if(N == 3) for(a in 0:final_values[1]) for(b in 0:final_values[2]) 
    for(c in 0:final_values[3]) {
      full_dir <- make_dir(input_dir, pars, c(a, b, c))
      res <- combine_dfs(full_dir, res)
    }
  
  if(N == 4) for(a in 0:final_values[1]) for(b in 0:final_values[2]) 
    for(c in 0:final_values[3]) for(d in 0:final_values[4]) {
      full_dir <- make_dir(input_dir, pars, c(a, b, c, d))
      res <- combine_dfs(full_dir, res)
    }
  
  if(N == 5) for(a in 0:final_values[1]) for(b in 0:final_values[2]) 
    for(c in 0:final_values[3]) for(d in 0:final_values[4]) for(e in 0:final_values[5]) {
      full_dir <- make_dir(input_dir, pars, c(a, b, c, d, e))
      res <- combine_dfs(full_dir, res)
    }
  
  return(res)
}

#' Get summary metrics for each simulation in a batch
#' 
#' @param data dataframe
#' @param start_size_range vector of NumCells at time of initial measurement for forecasting
#' @param gap_range vector of projection periods (gap between time of initial measurement and second measurement)
#' @param final_size waiting time is measured until tumour reaches this NumCells value
#' 
#' @return a dataframe that for each simulation has one row for each combination of "gap" and "start_size", 
#' and which has added columns "start_time" (proportional time until NumCells reached start_size), 
#' "end_time" (proportional time until NumCells reached end_size), 
#' "waiting_time" ("start_time" - "end_time"), and "outcome" (NumCells after "gap")
#' 
#' @import dplyr
#' @export
#' 
#' @examples
#' comb_df <- combine_dfs(system.file("extdata", "", package = "demonanalysis", mustWork = TRUE))
#' get_summary(comb_df, c(10, 20), c(0.1, 0.2), 100)
get_summary <- function(data, start_size_range, gap_range, final_size) {
  summary <- data.frame()
  parameter_column_nums <- 1:(which(colnames(data) == "Generation") - 1)
  data <- data %>% group_by_at(parameter_column_nums)
  for(start_size in start_size_range) {
    print("So far so good")
    for(gap in gap_range) {
      if(start_size < final_size) {
        new_summary1 <- data %>% 
          filter(NumCells >= start_size) %>% 
          summarise(start_time = min(gen_adj))
        new_summary2 <- data %>% 
          filter(NumCells >= final_size) %>% 
          summarise(end_time = min(gen_adj))
        new_summary12 <- merge(new_summary1, new_summary2, all.x = TRUE)
        new_summary12 <- new_summary12 %>% 
          mutate(waiting_time = end_time - start_time)
      }
      else {
        new_summary12 <- data %>% 
          filter(NumCells >= start_size) %>% 
          summarise(waiting_time = NA, start_time = NA, end_time = NA)
      }
      new_summary3 <- data %>% 
        filter(NumCells > start_size) %>% 
        filter(gen_adj < min(gen_adj) + gap) %>% 
        summarise(outcome = max(NumCells))
      new_summary3a <- data %>% 
        filter(NumCells > start_size) %>% 
        summarise(outcome = max(NumCells))
      new_summary3$outcome <- ifelse(new_summary3$outcome == new_summary3a$outcome, NA, new_summary3$outcome)
      new_summary4 <- data %>% 
        filter(NumCells > start_size) %>% 
        filter(gen_adj == min(gen_adj)) %>%
        mutate(gap = gap, start_size = start_size)
      summary <- rbind(summary, merge(merge(new_summary12, new_summary3, all.x = TRUE), new_summary4, all.x = TRUE))
    }
  }
  return(summary)
}





